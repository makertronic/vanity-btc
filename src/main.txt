use rand::Rng;
use sha2::{Sha256, Digest};
use ripemd::Ripemd160;
use secp256k1::{Secp256k1, SecretKey, PublicKey as Secp256k1PublicKey};

// Structure pour reprÃ©senter une clÃ© privÃ©e Bitcoin
#[derive(Debug, Clone)]
struct PrivateKey {
    secret_key: SecretKey,
}

// Structure pour reprÃ©senter une clÃ© publique Bitcoin
#[derive(Debug, Clone)]
struct PublicKey {
    public_key: Secp256k1PublicKey,
}

// Structure pour reprÃ©senter une adresse Bitcoin
#[derive(Debug)]
struct BitcoinAddress {
    private_key: PrivateKey,
    public_key: PublicKey,
    address: String,
}

impl PrivateKey {
    // GÃ©nÃ¨re une nouvelle clÃ© privÃ©e cryptographiquement sÃ©curisÃ©e
    fn generate() -> Self {
        let secp = Secp256k1::new();
        let mut rng = rand::thread_rng();
        
        // GÃ©nÃ©ration d'une clÃ© privÃ©e valide selon secp256k1
        let secret_key = SecretKey::new(&mut rng);
        
        PrivateKey { secret_key }
    }
    
    // Convertit la clÃ© privÃ©e en format WIF (Wallet Import Format)
    fn to_wif(&self) -> String {
        let mut extended_key = Vec::new();
        extended_key.push(0x80); // Version byte pour mainnet
        extended_key.extend_from_slice(&self.secret_key.secret_bytes());
        extended_key.push(0x01); // Suffix pour clÃ© publique compressÃ©e
        
        // Double SHA256 pour le checksum
        let hash1 = Sha256::digest(&extended_key);
        let hash2 = Sha256::digest(&hash1);
        
        // Ajouter les 4 premiers bytes du hash comme checksum
        extended_key.extend_from_slice(&hash2[0..4]);
        
        // Encoder en base58
        base58_encode(&extended_key)
    }
    
    // Convertit la clÃ© privÃ©e en format hexadÃ©cimal
    fn to_hex(&self) -> String {
        hex::encode(&self.secret_key.secret_bytes())
    }
    
    // GÃ©nÃ¨re la clÃ© publique correspondante avec la vraie multiplication scalaire
    fn to_public_key(&self) -> PublicKey {
        let secp = Secp256k1::new();
        
        // âœ… VRAIE multiplication scalaire : pubkey = privkey Ã— G
        // Ceci effectue la vraie multiplication sur la courbe elliptique secp256k1
        let public_key = Secp256k1PublicKey::from_secret_key(&secp, &self.secret_key);
        
        PublicKey { public_key }
    }
    
    // Obtient les bytes bruts de la clÃ© privÃ©e
    fn as_bytes(&self) -> &[u8] {
        &self.secret_key.secret_bytes()
    }
}

impl PublicKey {
    // Convertit la clÃ© publique en format hexadÃ©cimal (compressÃ©e)
    fn to_hex(&self) -> String {
        hex::encode(&self.public_key.serialize())
    }
    
    // Convertit la clÃ© publique en format hexadÃ©cimal (non-compressÃ©e)
    fn to_hex_uncompressed(&self) -> String {
        hex::encode(&self.public_key.serialize_uncompressed())
    }
    
    // GÃ©nÃ¨re l'adresse Bitcoin P2PKH (Legacy) correspondante
    fn to_address(&self) -> String {
        // Utiliser la clÃ© publique compressÃ©e pour l'adresse
        let pubkey_bytes = self.public_key.serialize();
        
        // Ã‰tape 1: SHA256 de la clÃ© publique compressÃ©e
        let sha256_hash = Sha256::digest(&pubkey_bytes);
        
        // Ã‰tape 2: RIPEMD160 du rÃ©sultat SHA256
        let mut ripemd_hasher = Ripemd160::new();
        ripemd_hasher.update(&sha256_hash);
        let ripemd_hash = ripemd_hasher.finalize();
        
        // Ã‰tape 3: Ajouter le version byte (0x00 pour P2PKH mainnet)
        let mut extended_hash = Vec::new();
        extended_hash.push(0x00);
        extended_hash.extend_from_slice(&ripemd_hash);
        
        // Ã‰tape 4: Double SHA256 pour le checksum
        let hash1 = Sha256::digest(&extended_hash);
        let hash2 = Sha256::digest(&hash1);
        
        // Ã‰tape 5: Ajouter les 4 premiers bytes du checksum
        extended_hash.extend_from_slice(&hash2[0..4]);
        
        // Ã‰tape 6: Encoder en base58
        base58_encode(&extended_hash)
    }
    
    // Obtient les bytes de la clÃ© publique compressÃ©e
    fn as_bytes(&self) -> [u8; 33] {
        self.public_key.serialize()
    }
    
    // Obtient les bytes de la clÃ© publique non-compressÃ©e
    fn as_bytes_uncompressed(&self) -> [u8; 65] {
        self.public_key.serialize_uncompressed()
    }
}

impl BitcoinAddress {
    // GÃ©nÃ¨re une nouvelle adresse Bitcoin complÃ¨te avec vraie cryptographie
    fn generate() -> Self {
        let private_key = PrivateKey::generate();
        let public_key = private_key.to_public_key();
        let address = public_key.to_address();
        
        BitcoinAddress {
            private_key,
            public_key,
            address,
        }
    }
    
    // GÃ©nÃ¨re une adresse contenant un mot spÃ©cifique
    fn generate_vanity(target: &str, case_sensitive: bool) -> (Self, u64) {
        let mut attempts = 0u64;
        
        loop {
            attempts += 1;
            let address = Self::generate();
            
            let contains_target = if case_sensitive {
                address.address.contains(target)
            } else {
                address.address.to_lowercase().contains(&target.to_lowercase())
            };
            
            if contains_target {
                return (address, attempts);
            }
            
            // Afficher le progrÃ¨s toutes les 50000 tentatives
            if attempts % 50000 == 0 {
                println!("   ... {} tentatives effectuÃ©es", attempts);
            }
        }
    }
    
    // GÃ©nÃ¨re une adresse commenÃ§ant par un prÃ©fixe spÃ©cifique
    fn generate_prefix(prefix: &str, case_sensitive: bool) -> (Self, u64) {
        let mut attempts = 0u64;
        
        loop {
            attempts += 1;
            let address = Self::generate();
            
            let starts_with_prefix = if case_sensitive {
                address.address[1..].starts_with(prefix) // [1..] pour ignorer le '1' initial
            } else {
                address.address[1..].to_lowercase().starts_with(&prefix.to_lowercase())
            };
            
            if starts_with_prefix {
                return (address, attempts);
            }
            
            // Afficher le progrÃ¨s toutes les 50000 tentatives
            if attempts % 50000 == 0 {
                println!("   ... {} tentatives effectuÃ©es", attempts);
            }
        }
    }
    
    // Affiche toutes les informations de l'adresse
    fn display(&self) {
        println!("=== Adresse Bitcoin gÃ©nÃ©rÃ©e ===");
        println!("ClÃ© privÃ©e (HEX): {}", self.private_key.to_hex());
        println!("ClÃ© privÃ©e (WIF): {}", self.private_key.to_wif());
        println!("ClÃ© publique compressÃ©e (HEX): {}", self.public_key.to_hex());
        println!("ClÃ© publique non-compressÃ©e (HEX): {}", self.public_key.to_hex_uncompressed());
        println!("Adresse Bitcoin: {}", self.address);
        println!("===============================");
    }
    
    // Affiche avec statistiques de gÃ©nÃ©ration
    fn display_with_stats(&self, attempts: u64, elapsed: std::time::Duration) {
        println!("=== Adresse Bitcoin Vanity gÃ©nÃ©rÃ©e ===");
        println!("Tentatives: {}", attempts);
        println!("Temps Ã©coulÃ©: {:?}", elapsed);
        println!("Vitesse: {:.2} adresses/sec", attempts as f64 / elapsed.as_secs_f64());
        println!("ClÃ© privÃ©e (HEX): {}", self.private_key.to_hex());
        println!("ClÃ© privÃ©e (WIF): {}", self.private_key.to_wif());
        println!("ClÃ© publique compressÃ©e (HEX): {}", self.public_key.to_hex());
        println!("Adresse Bitcoin: {}", self.address);
        println!("=====================================");
    }
    
    // VÃ©rifie la validitÃ© cryptographique de l'adresse
    fn verify_cryptographic_validity(&self) -> bool {
        // VÃ©rifier que la clÃ© publique correspond bien Ã  la clÃ© privÃ©e
        let secp = Secp256k1::new();
        let expected_pubkey = Secp256k1PublicKey::from_secret_key(&secp, &self.private_key.secret_key);
        
        // VÃ©rifier que l'adresse correspond bien Ã  la clÃ© publique
        let expected_address = self.public_key.to_address();
        
        expected_pubkey == self.public_key.public_key && expected_address == self.address
    }
}

// Encodage Base58 avec gestion des grands nombres
fn base58_encode(data: &[u8]) -> String {
    const ALPHABET: &[u8] = b"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
    
    // Compter les zÃ©ros en tÃªte
    let leading_zeros = data.iter().take_while(|&&b| b == 0).count();
    
    // Utiliser un vecteur pour gÃ©rer les grands nombres
    let mut digits = vec![0u8];
    
    // Convertir byte par byte pour Ã©viter l'overflow
    for &byte in data {
        let mut carry = byte as u32;
        
        for digit in digits.iter_mut() {
            carry += (*digit as u32) * 256;
            *digit = (carry % 58) as u8;
            carry /= 58;
        }
        
        while carry > 0 {
            digits.push((carry % 58) as u8);
            carry /= 58;
        }
    }
    
    // Ajouter les '1' pour les zÃ©ros en tÃªte
    let mut result = vec![ALPHABET[0]; leading_zeros];
    
    // Convertir les digits en caractÃ¨res (en inversant l'ordre)
    for &digit in digits.iter().rev() {
        if digit != 0 || !result.is_empty() || leading_zeros == 0 {
            result.push(ALPHABET[digit as usize]);
        }
    }
    
    // Si le rÃ©sultat est vide, retourner '1'
    if result.is_empty() {
        result.push(ALPHABET[0]);
    }
    
    String::from_utf8(result).unwrap()
}

fn main() {
    println!("ğŸš€ GÃ©nÃ©rateur d'adresses Bitcoin Vanity avec VRAIE cryptographie ECDSA");
    println!("=====================================================================\n");
    
    // Test de validation cryptographique
    println!("ğŸ” Test de validation cryptographique...");
    let test_address = BitcoinAddress::generate();
    if test_address.verify_cryptographic_validity() {
        println!("âœ… Validation rÃ©ussie - Les clÃ©s sont cryptographiquement correctes!");
    } else {
        println!("âŒ Erreur de validation cryptographique!");
        return;
    }
    println!();
    
    // Exemple 1: Recherche d'adresses contenant des mots courts
    println!("ğŸ“ Mode 1: Recherche de mots courts dans l'adresse");
    let target_words = vec!["aa", "bb"]; // Mots courts pour dÃ©monstration
    
    for word in target_words {
        println!("ğŸ” Recherche d'une adresse contenant '{}'...", word);
        let start_time = std::time::Instant::now();
        
        let (address, attempts) = BitcoinAddress::generate_vanity(word, false);
        let elapsed = start_time.elapsed();
        
        println!("âœ… TrouvÃ© aprÃ¨s {} tentatives en {:?}!", attempts, elapsed);
        address.display_with_stats(attempts, elapsed);
        
        // VÃ©rification cryptographique
        if address.verify_cryptographic_validity() {
            println!("âœ… Adresse cryptographiquement valide!");
        } else {
            println!("âŒ Erreur: Adresse invalide!");
        }
        println!();
    }
    
    // Exemple 2: GÃ©nÃ©ration d'une adresse simple avec tous les dÃ©tails
    println!("ğŸ² Mode 2: GÃ©nÃ©ration d'une adresse complÃ¨te");
    let address = BitcoinAddress::generate();
    address.display();
    
    // Informations techniques sur secp256k1
    println!("\nğŸ”¬ Informations techniques:");
    println!("- Courbe elliptique: secp256k1 (yÂ² = xÂ³ + 7)");
    println!("- Champ fini: p = 2Â²âµâ¶ - 2Â³Â² - 2â¹ - 2â¸ - 2â· - 2â¶ - 2â´ - 1");
    println!("- Ordre: n = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141");
    println!("- Point gÃ©nÃ©rateur G: coordonnÃ©es fixes sur la courbe");
    println!("- Multiplication scalaire: ClÃ©_publique = clÃ©_privÃ©e Ã— G");
    println!("- SÃ©curitÃ©: ProblÃ¨me du logarithme discret elliptique");
    
    println!("\nğŸ’¡ Optimisations possibles:");
    println!("   - Utiliser plusieurs threads (rayon crate)");
    println!("   - PrÃ©-calculer des tables de multiplication");
    println!("   - Utiliser des optimisations SIMD");
    println!("   - GÃ©nÃ©rer par batch pour rÃ©duire les allocations");
    
    println!("\nâš ï¸  ATTENTION: MÃªme avec la vraie cryptographie, ces clÃ©s");
    println!("   sont Ã  des fins de dÃ©monstration. Utilisez un gÃ©nÃ©rateur");
    println!("   auditÃ© et sÃ©curisÃ© pour de vrais Bitcoin!");
}

// DÃ©pendances nÃ©cessaires dans Cargo.toml:
/*
[dependencies]
secp256k1 = { version = "0.29", features = ["rand"] }
rand = "0.8"
sha2 = "0.10"
ripemd = "0.1"
hex = "0.4"
*/